@page "/"

@using FluentUI.TripPin.Model
@using FluentUI.TripPin.Controls
@using Microsoft.OData.Edm
@using System.Linq.Expressions
@using System.Reflection

<PageTitle>@Entity</PageTitle>

<FluentStack VerticalAlignment="VerticalAlignment.Center">
    <FluentLabel Typo="Typography.PageTitle" Color="Color.Accent">@Entity</FluentLabel>
    <FluentStack HorizontalAlignment="HorizontalAlignment.End">
        <FluentSwitch @bind-Value="@Virtualize" Disabled="@(Entity is null)" Label="Virtualize" />
    </FluentStack>
</FluentStack>

<ErrorBoundary @ref="_errorBoundary">
    <ChildContent>
        @_childContent
    </ChildContent>
    <ErrorContent Context="ex">
        <div class="blazor-error-boundary">@ex.Message</div>
    </ErrorContent>
</ErrorBoundary>

@code {
    private RenderFragment? _childContent;
    private ErrorBoundary? _errorBoundary;

    [SupplyParameterFromQuery]
    private string? Entity { get; set; }

    [SupplyParameterFromQuery]
    private bool Virtualize { get; set; }

    [Inject]
    private Container Container { get; set; } = default!;

    protected override void OnParametersSet()
    {
        _errorBoundary?.Recover();

        if (Entity == null)
            return;

        var model = Container.Format.LoadServiceModel();
        var entitySet = model.EntityContainer.FindEntitySet(Entity);

        if (entitySet == null)
            return;

        var containerType = typeof(Container);
        var entityType = Type.GetType($"{containerType.Namespace}.{entitySet.EntityType.Name}", true)!;
        var items = containerType.GetMethod(nameof(Container.CreateQuery), [typeof(string)])!
            .MakeGenericMethod(entityType).Invoke(Container, [entitySet.Name]);

        var content = FluentDataGridEntityHelpers.ColumnsRenderFragment(entitySet,
            Container.ResolveType, prop => new Dictionary<string, object> { { "Sortable", true } });

        var comparer = BuildEqualityComparer(entitySet, Container.ResolveType);

        _childContent = builder =>
        {
            builder.OpenComponent(0, typeof(PaginatedDataGrid<>).MakeGenericType(entityType));
            builder.AddAttribute(1, "Items", items);
            builder.AddAttribute(2, "ChildContent", content);
            builder.AddAttribute(3, "Comparer", comparer);
            builder.AddAttribute(4, "SelectMode", DataGridSelectMode.Multiple);
            builder.AddAttribute(5, "Virtualize", Virtualize);
            builder.CloseComponent();
        };
    }

    public static object? BuildEqualityComparer(IEdmEntitySet entitySet, Func<string, Type> resolveType)
    {
        var propertyNames = entitySet.EntityType.DeclaredKey.Any()
            ? entitySet.EntityType.DeclaredKey.Select(p => p.Name).ToArray()
            : entitySet.EntityType.DeclaredProperties.Where(p => !p.Type.IsCollection() && !p.Type.IsComplex()).Select(p => p.Name).ToArray();
        var clrType = resolveType(entitySet.EntityType.FullTypeName());
        
        if (propertyNames.Length == 0 || clrType == null)
            return null;

        var parameter = Expression.Parameter(clrType, "x");
        var propertyAccesses = new List<Expression>();

        foreach (var name in propertyNames)
        {
            var property = clrType.GetProperty(name, BindingFlags.Public | BindingFlags.Instance)
                ?? throw new ArgumentException($"Property '{name}' not found on type {clrType.Name}");
            propertyAccesses.Add(Expression.Convert(Expression.Property(parameter, property), typeof(object)));
        }

        var delegateType = typeof(Func<,>).MakeGenericType(clrType, typeof(object[]));
        var expression = Expression.Lambda(delegateType, Expression.NewArrayInit(typeof(object), propertyAccesses), parameter);

        return Activator.CreateInstance(typeof(EntityEqualityComparer<>).MakeGenericType(clrType), expression.Compile());
    }

    public sealed class EntityEqualityComparer<T>(Func<T, object[]> selector) : IEqualityComparer<T>
    {
        public bool Equals(T? x, T? y)
        {
            if (ReferenceEquals(x, y))
            {
                return true;
            }

            if (x is null || y is null)
            {
                return false;
            }

            return selector(x).SequenceEqual(selector(y));
        }

        public int GetHashCode(T obj) => selector(obj).GetHashCode();
    }
}
